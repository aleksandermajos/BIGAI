# agent_qwq_inet_weather.py
# -------------------------------------------
# Agent z modelem QwQ 32B (Ollama) + Internet:
# â€¢ search_web  â€“ wyszukuje i scrapuje strony (DuckDuckGo) z retry & cache
# â€¢ get_weather â€“ pobiera bieÅ¼Ä…cÄ… pogodÄ™ (Open-Meteo) bez klucza API
#
# Instalacja:
#   pip install -U \
#       ollama langchain-core langgraph langchain-ollama \
#       duckduckgo_search beautifulsoup4 requests
#   ollama pull qwq:32b
# Uruchom:
#   python agent_qwq_inet_weather.py
# -------------------------------------------

import textwrap, requests, bs4, datetime, time, random, functools
from typing import Sequence, Annotated, TypedDict

from duckduckgo_search import DDGS
from langchain_core.tools import tool
from langchain_core.messages import HumanMessage, AIMessage
from langchain_ollama import ChatOllama
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolNode, tools_condition
from langgraph.graph.message import add_messages

# ---------------------------------------------------------------------------
# 1) TOOL: wyszukiwarka z cacheâ€™em i exponential back-off na HTTP 202 (rate-limit)
# ---------------------------------------------------------------------------

# PamiÄ™Ä‡ podrÄ™czna w RAM â€“ 128 ostatnich zapytaÅ„ (z duplikatami parametrÃ³w)
def lru_cache(maxsize=128):
    def decorator(func):
        cache = {}
        order = []
        @functools.wraps(func)
        def wrapped(*args):
            if args in cache:
                return cache[args]
            result = func(*args)
            cache[args] = result
            order.append(args)
            if len(order) > maxsize:
                oldest = order.pop(0)
                cache.pop(oldest, None)
            return result
        return wrapped
    return decorator

@lru_cache(maxsize=128)
def ddg_query(query: str, max_results: int):
    """Jedno zapytanie DDG z retry na 202 (ratelimit)."""
    delay = 2
    for _ in range(6):                              # max 6 prÃ³b â‰ˆ 2 + 4 + 8 + â€¦ = 126 s
        hits = list(DDGS().text(query, max_results=max_results))
        if hits and hits[0].get("status_code") != 202:
            return hits
        time.sleep(delay + random.uniform(0.0, 1.0))
        delay *= 2                                  # podwajamy opÃ³Åºnienie
    return []                                       # po przekroczeniu limitu â€“ pusta lista

from ENGINE.KEY_BRAVE import provide_key
BASE_URL  = "https://api.search.brave.com/res/v1/web/search"
@tool
def search_web(query: str, k: int = 5) -> str:
    """Wyszukuje Brave Search API, zwraca k skrÃ³conych wynikÃ³w."""
    if not BRAVE_KEY:
        return "[Brak klucza BRAVE_API_KEY w zmiennych Å›rodowiska]"

    params  = {"q": query, "count": k}
    headers = {"X-Subscription-Token": BRAVE_KEY, "Accept": "application/json"}

    try:
        data = requests.get(BASE_URL, params=params,
                            headers=headers, timeout=8).json()
        results = data["web"]["results"]
    except Exception as e:
        return f"[BÅ‚Ä…d Brave API: {e}]"

    out = []
    for i, r in enumerate(results, 1):
        url, snippet = r["url"], r.get("description", "")
        snippet = textwrap.shorten(snippet or url, 700, placeholder=" â€¦")
        out.append(f"[{i}] {url}\n{snippet}\n")

    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    return f"(Brave Search â€“ {ts})\n\n" + "\n".join(out)


# ---------------------------------------------------------------------------
# 2) TOOL: aktualna pogoda z Open-Meteo (bez klucza i limitÃ³w praktycznych)
# ---------------------------------------------------------------------------
CITY_COORDS = {
    "WrocÅ‚aw":   (51.1079, 17.0385),
    "Warszawa":  (52.2297, 21.0122),
    "KrakÃ³w":    (50.0647, 19.9450),
    "GdaÅ„sk":    (54.3520, 18.6466),
}

@tool
def get_weather(city: str = "WrocÅ‚aw") -> str:
    """
    Zwraca bieÅ¼Ä…cÄ… pogodÄ™ (temperatura Â°C, wiatr km/h, kod warunkÃ³w) z Open-Meteo.
    ObsÅ‚uguje tylko miasta z predefiniowanej listy CITY_COORDS.
    """
    if city not in CITY_COORDS:
        return f"Miasto {city} nieobsÅ‚ugiwane (dostÄ™pne: {', '.join(CITY_COORDS)})"
    lat, lon = CITY_COORDS[city]
    url = (f"https://api.open-meteo.com/v1/forecast?"
           f"latitude={lat}&longitude={lon}&current_weather=true")
    try:
        data = requests.get(url, timeout=8).json()["current_weather"]
        return (f"Pogoda w {city}: {data['temperature']} Â°C, "
                f"wiatr {data['windspeed']} km/h, "
                f"kod warunkÃ³w {data['weathercode']} "
                f"(odczyt {data['time']}).")
    except Exception as e:
        return f"[bÅ‚Ä…d pobierania pogody: {e}]"


# ---------------------------------------------------------------------------
# 3) MODEL QwQ 32B + powiÄ…zanie z narzÄ™dziami
# ---------------------------------------------------------------------------
tools = [search_web, get_weather]
llm = ChatOllama(model="qwq:32b", temperature=0.2).bind_tools(tools)

SYSTEM_PROMPT = (
    "You are an assistant with real-time internet tools. "
    "Call the tools when they can provide fresh data; "
    "then answer the user in Polish."
)

# ---------------------------------------------------------------------------
# 4) LangGraph â€“ graf stanÃ³w
# ---------------------------------------------------------------------------
class AgentState(TypedDict):
    messages: Annotated[Sequence, add_messages]

graph = StateGraph(AgentState)

# â€” wÄ™zeÅ‚: model
def chatbot(state: AgentState):
    reply_msg = llm.invoke(state["messages"])
    return {"messages": [reply_msg]}

graph.add_node("chatbot", chatbot)

# â€” wÄ™zeÅ‚: wykonanie narzÄ™dzi
graph.add_node("tools", ToolNode(tools))

# Start: model
graph.set_entry_point("chatbot")

# Routing: jeÅ›li model zwrÃ³ci tool_calls â†’ do wÄ™zÅ‚a tools; inaczej koniec
graph.add_conditional_edges(
    "chatbot",
    tools_condition,
    {"tools": "tools", "__end__": END},
)

# Po wykonaniu narzÄ™dzia wracamy do modelu
graph.add_edge("tools", "chatbot")

agent = graph.compile()

# ---------------------------------------------------------------------------
# 5) REPL
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    print("Agent QwQ 32B + Internet + Pogoda.  Ctrl-C aby zakoÅ„czyÄ‡.\n")
    state: AgentState = {"messages": [{"role": "system", "content": SYSTEM_PROMPT}]}
    try:
        while True:
            user = input("ðŸ§‘ Ty: ")
            state["messages"].append(HumanMessage(content=user))
            state = agent.invoke(state)
            answer = state["messages"][-1]          # ostatnia wiadomoÅ›Ä‡ od bota
            print(f"ðŸ¤– Bot: {answer.content}\n")
    except KeyboardInterrupt:
        print("\nDo zobaczenia!")
